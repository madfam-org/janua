name: Validate User Journeys

# Validates that user experience matches marketing claims and documentation
# Runs on changes to landing pages, API, SDKs, or journey documentation

on:
  workflow_dispatch:  # Allow manual triggering
  push:
    branches: [main, develop]
    paths:
      - 'apps/website/**'
      - 'apps/api/**'
      - 'apps/dashboard/**'
      - 'packages/**'
      - 'docs/user-journeys/**'
      - 'tests/e2e/journeys/**'
      - 'config/docker-compose.test.yml'
  pull_request:
    branches: [main, develop]
    paths:
      - 'apps/website/**'
      - 'apps/api/**'
      - 'apps/dashboard/**'
      - 'packages/**'
      - 'docs/user-journeys/**'
      - 'tests/e2e/journeys/**'
      - 'config/docker-compose.test.yml'

jobs:
  validate-journeys:
    name: Validate User Journeys
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Setup Python (for API)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install system dependencies for xmlsec
        run: |
          sudo apt-get update
          sudo apt-get install -y libxmlsec1-dev pkg-config

      - name: Install Python dependencies
        run: |
          cd apps/api
          pip install -r requirements.txt

      - name: Start database services only
        run: |
          docker compose -f config/docker-compose.test.yml up -d postgres redis
          echo "Database services starting..."

      - name: Wait for databases to be healthy
        run: |
          echo "Waiting for PostgreSQL..."
          timeout 120s bash -c 'until docker exec janua-postgres-test pg_isready -U test_user -d janua_test; do sleep 2; done'
          echo "PostgreSQL is healthy"

          echo "Waiting for Redis..."
          timeout 60s bash -c 'until docker exec janua-redis-test redis-cli ping | grep -q PONG; do sleep 2; done'
          echo "Redis is healthy"

      - name: Start API server
        run: |
          cd apps/api
          ENVIRONMENT=test \
          DATABASE_URL="postgresql://test_user:test_pass@localhost:5432/janua_test" \
          REDIS_URL="redis://localhost:6379/0" \
          JWT_SECRET_KEY="test_jwt_secret_github_actions" \
          python -m uvicorn app.main:app --host 0.0.0.0 --port 8000 &
          echo $! > /tmp/api.pid
          echo "API server started in background"

      - name: Wait for API to be ready
        run: |
          echo "Waiting for API health check..."
          timeout 120s bash -c 'until curl -f http://localhost:8000/health; do sleep 2; done'
          echo "API is healthy and ready"

      - name: Install landing page dependencies
        run: |
          cd apps/website
          npm install

      - name: Build landing page
        run: |
          cd apps/website
          npm run build

      - name: Start landing page
        run: |
          cd apps/website
          npm start &
          echo $! > /tmp/landing.pid
          echo "Landing page started in background on port 3000"

      - name: Wait for landing page to be ready
        run: |
          echo "Waiting for landing page..."
          timeout 120s bash -c 'until curl -f http://localhost:3000 2>/dev/null; do sleep 2; done'
          echo "Landing page is healthy and ready"

      - name: Install test-app dependencies
        run: |
          cd tests/test-app
          npm install

      - name: Build test-app
        run: |
          cd tests/test-app
          npm run build

      - name: Start test-app
        run: |
          cd tests/test-app
          JANUA_API_URL="http://localhost:8000" \
          JANUA_API_KEY="test-api-key" \
          PORT=3001 \
          npm start &
          echo $! > /tmp/test-app.pid
          echo "Test app started in background on port 3001"

      - name: Wait for test-app to be ready
        run: |
          echo "Waiting for test-app..."
          timeout 120s bash -c 'until curl -f http://localhost:3001 2>/dev/null; do sleep 2; done'
          echo "Test-app is healthy and ready"

      - name: Run journey validation tests
        run: npx playwright test tests/e2e/journeys --reporter=github

      - name: Generate HTML report
        if: always()
        run: npx playwright show-report --host 0.0.0.0

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: test-results/
          retention-days: 30

      - name: Check for journey validation failures
        if: failure()
        run: |
          echo "âŒ User journey validation failed!"
          echo "This indicates a mismatch between:"
          echo "  - Marketing claims and actual functionality"
          echo "  - Documentation and SDK behavior"
          echo "  - Pricing page and billing enforcement"
          echo ""
          echo "Please review the Playwright report for details."
          exit 1

      - name: Stop test-app
        if: always()
        run: |
          if [ -f /tmp/test-app.pid ]; then
            kill $(cat /tmp/test-app.pid) 2>/dev/null || true
          fi
          pkill -f "node.*test-app" || true

      - name: Stop landing page
        if: always()
        run: |
          if [ -f /tmp/landing.pid ]; then
            kill $(cat /tmp/landing.pid) 2>/dev/null || true
          fi
          pkill -f "next start" || true

      - name: Stop API server
        if: always()
        run: |
          if [ -f /tmp/api.pid ]; then
            kill $(cat /tmp/api.pid) 2>/dev/null || true
          fi
          pkill -f "uvicorn app.main:app" || true

      - name: Cleanup database services
        if: always()
        run: docker compose -f config/docker-compose.test.yml down -v

  validate-content-alignment:
    name: Validate Content-Functionality Alignment
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Check for undocumented features
        run: |
          echo "ðŸ” Checking for features in code but not documented..."
          # Search for feature implementations
          FEATURES=$(grep -r "feature" apps/api --include="*.py" | wc -l || true)
          echo "Found $FEATURES feature references in API code"

      - name: Build SDKs for validation
        run: |
          echo "ðŸ”¨ Building SDK packages..."
          
          # Build each SDK (dist/ directories are build artifacts, not in git)
          for SDK in typescript-sdk nextjs-sdk react-sdk vue-sdk; do
            if [ -f "packages/$SDK/package.json" ]; then
              echo "Building $SDK..."
              cd "packages/$SDK"
              npm install --legacy-peer-deps 2>/dev/null || npm install 2>/dev/null || true
              npm run build 2>/dev/null || echo "âš ï¸ $SDK: No build script or build failed"
              cd ../..
            fi
          done

      - name: Validate SDK distribution files exist
        run: |
          echo "ðŸ“¦ Validating SDK distribution files..."
          
          # Check if builds succeeded (dist/ should now exist)
          FAILED=0
          for SDK in typescript-sdk nextjs-sdk react-sdk vue-sdk; do
            echo "Checking packages/$SDK/dist/"
            if [ -d "packages/$SDK/dist" ]; then
              FILES=$(ls packages/$SDK/dist 2>/dev/null | wc -l)
              echo "âœ… $SDK: $FILES distribution files"
            else
              echo "âš ï¸ $SDK: dist/ directory missing (build may have failed)"
              FAILED=1
            fi
          done
          
          # Don't fail workflow - dist/ validation is informational only
          if [ $FAILED -eq 1 ]; then
            echo "âš ï¸ Some SDKs missing dist/ - this is expected if builds are not configured"
            echo "   SDKs will be built during actual publishing workflow"
          fi

      - name: Validate documentation links
        run: |
          echo "ðŸ”— Validating documentation links..."
          
          # Check for broken internal links in journey docs
          cd docs/user-journeys
          for file in *.md; do
            echo "Checking $file..."
            grep -o '\[.*\](.*\.md)' "$file" || true
          done

  performance-validation:
    name: Validate Performance Claims
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Playwright
        run: npx playwright install --with-deps chromium

      - name: Setup Python (for API)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install system dependencies for xmlsec
        run: |
          sudo apt-get update
          sudo apt-get install -y libxmlsec1-dev pkg-config

      - name: Install Python dependencies
        run: |
          cd apps/api
          pip install -r requirements.txt

      - name: Start database services only
        run: |
          docker compose -f config/docker-compose.test.yml up -d postgres redis
          echo "Database services starting..."

      - name: Wait for databases to be healthy
        run: |
          echo "Waiting for PostgreSQL..."
          timeout 120s bash -c 'until docker exec janua-postgres-test pg_isready -U test_user -d janua_test; do sleep 2; done'
          echo "PostgreSQL is healthy"

          echo "Waiting for Redis..."
          timeout 60s bash -c 'until docker exec janua-redis-test redis-cli ping | grep -q PONG; do sleep 2; done'
          echo "Redis is healthy"

      - name: Start API server
        run: |
          cd apps/api
          ENVIRONMENT=test \
          DATABASE_URL="postgresql://test_user:test_pass@localhost:5432/janua_test" \
          REDIS_URL="redis://localhost:6379/0" \
          JWT_SECRET_KEY="test_jwt_secret_github_actions" \
          python -m uvicorn app.main:app --host 0.0.0.0 --port 8000 &
          echo $! > /tmp/api.pid
          echo "API server started in background"

      - name: Wait for API to be ready
        run: |
          echo "Waiting for API health check..."
          timeout 120s bash -c 'until curl -f http://localhost:8000/health; do sleep 2; done'
          echo "API is healthy and ready"

      - name: Install landing page dependencies
        run: |
          cd apps/website
          npm install

      - name: Build landing page
        run: |
          cd apps/website
          npm run build

      - name: Start landing page
        run: |
          cd apps/website
          npm start &
          echo $! > /tmp/landing.pid
          echo "Landing page started in background on port 3000"

      - name: Wait for landing page to be ready
        run: |
          echo "Waiting for landing page..."
          timeout 120s bash -c 'until curl -f http://localhost:3000 2>/dev/null; do sleep 2; done'
          echo "Landing page is healthy and ready"

      - name: Install test-app dependencies
        run: |
          cd tests/test-app
          npm install

      - name: Build test-app
        run: |
          cd tests/test-app
          npm run build

      - name: Start test-app
        run: |
          cd tests/test-app
          JANUA_API_URL="http://localhost:8000" \
          JANUA_API_KEY="test-api-key" \
          PORT=3001 \
          npm start &
          echo $! > /tmp/test-app.pid
          echo "Test app started in background on port 3001"

      - name: Wait for test-app to be ready
        run: |
          echo "Waiting for test-app..."
          timeout 120s bash -c 'until curl -f http://localhost:3001 2>/dev/null; do sleep 2; done'
          echo "Test-app is healthy and ready"

      - name: Run performance tests
        run: |
          npx playwright test tests/e2e/journeys/developer-integrator.spec.ts \
            -g "Performance meets documented expectations" \
            --reporter=github

      - name: Stop test-app
        if: always()
        run: |
          if [ -f /tmp/test-app.pid ]; then
            kill $(cat /tmp/test-app.pid) 2>/dev/null || true
          fi
          pkill -f "node.*test-app" || true

      - name: Stop landing page
        if: always()
        run: |
          if [ -f /tmp/landing.pid ]; then
            kill $(cat /tmp/landing.pid) 2>/dev/null || true
          fi
          pkill -f "next start" || true

      - name: Stop API server
        if: always()
        run: |
          if [ -f /tmp/api.pid ]; then
            kill $(cat /tmp/api.pid) 2>/dev/null || true
          fi
          pkill -f "uvicorn app.main:app" || true

      - name: Cleanup database services
        if: always()
        run: docker compose -f config/docker-compose.test.yml down -v

  notify-on-failure:
    name: Notify on Journey Validation Failure
    runs-on: ubuntu-latest
    needs: [validate-journeys, validate-content-alignment, performance-validation]
    if: failure()
    permissions:
      issues: write
      contents: read

    steps:
      - name: Create or update issue for journey validation failure
        uses: actions/github-script@v7
        with:
          script: |
            const title = 'ðŸš¨ User Journey Validation Failed';
            const labels = ['bug', 'user-journey', 'high-priority'];

            // Search for existing open issue with same title
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'user-journey',
              per_page: 10
            });

            const existingIssue = existingIssues.data.find(issue =>
              issue.title === title
            );

            const failureDetails = `
            ### Failed Run Details

            - **Run**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - **Branch**: \`${{ github.ref_name }}\`
            - **Commit**: \`${{ github.sha }}\`
            - **Triggered by**: @${{ github.actor }}
            - **Time**: ${new Date().toISOString()}
            `;

            if (existingIssue) {
              // Add comment to existing issue instead of creating duplicate
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `## ðŸ”„ Another Failure Detected\n${failureDetails}\n\nPlease review the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.`
              });
              console.log(`Added comment to existing issue #${existingIssue.number}`);
            } else {
              // Create new issue only if none exists
              const body = `
            ## User Journey Validation Failure

            The user journey validation tests have failed, indicating a potential mismatch between:

            - Marketing claims and actual implemented functionality
            - Documentation examples and SDK behavior
            - Pricing page promises and billing service enforcement
            - Performance claims and actual measurements

            ### Actions Required

            1. Review the [Playwright test report](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            2. Identify which journey stage failed
            3. Update either:
               - Marketing/documentation to match implementation
               - Implementation to match marketing promises
            4. Re-run journey validation tests

            ${failureDetails}

            cc @janua/engineering

            ---
            *This issue tracks all User Journey validation failures. New failures will be added as comments rather than creating duplicate issues.*
            `;

              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: labels
              });
              console.log(`Created new issue #${newIssue.data.number}`);
            }
